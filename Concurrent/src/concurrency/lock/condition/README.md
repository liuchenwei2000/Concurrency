## signalAll、signal 和死锁 ##

最终必须要有某个线程调用 signalAll 方法，这一点很重要。当一个线程调用了 await 时，它无法自己解除阻塞状态，它把自己的命运交给了其他线程。如果没有任何其他的线程来解除等待线程的阻塞状态，它就永远也不会运行了，这就会导致死锁。

适时调用 signalAll 的原则：当对象的状态向着有利于等待线程的方向变化时调用。例如，当一个账户余额发生变化时，等待线程应该有机会去检查余额。

需要注意的是，对 signalAll 的调用不会立即激活等待线程，它只是解除等待线程的阻塞状态，这样这些线程就可以在当前线程退出同步方法（释放对象锁）后，通过竞争获得对对象的访问。

singal 方法是随机解除等待集中某个线程的阻塞状态，这比解除所有线程的阻塞状态更好用，但也存在危险。如果被随机选中的线程发现自己还是无法运行，它会被再次阻塞，如果没有任何其他线程再次调用 signal 方法，那么系统就死锁了。

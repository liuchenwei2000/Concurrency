## 并发集合类 ##

Java 提供了两种类型的集合供并发环境使用：

* 阻塞集合（Blocking collections）

	这类集合包含增加、删除元素的操作，若这些操作不能立即执行（比如因为集合已满或为空所致），那执行该操作的线程将会被阻塞（blocked）直到操作可以执行。

* 非阻塞集合（Non-blocking collections）

	这类集合也包含增加、删除元素的操作，若这些操作不能立即执行（比如因为集合已满或为空所致），那该操作将直接返回 null 或者抛出异常而不会被阻塞。


### 阻塞集合产生背景

对于实际编程来说，应该尽可能远离底层结构，使用由并发处理的专业人士实现的较高层次的结构要更方便、更安全。（当然，线程安全的队列类的实现者不能不考虑锁和条件）对于许多线程问题，可以通过使用一个或多个队列以优雅且安全的方式将其形式化——比如生产者消费者模型。
生产者线程向队列插入元素，消费者线程则取出它们。使用阻塞队列，可以安全地从一个线程向另一个线程传递数据。

例如银行转账程序，转账线程将转账指令对象插入一个队列中，而不是直接访问银行对象；另一个线程从队列中取出指令执行转账，只有此线程可以访问银行对象，因此不需要同步。

阻塞队列 BlockingQueue 很好地解决了多线程中如何高效安全传输数据的问题，通过这些高效并且线程安全的队列类，可以更快的搭建高质量的多线程程序。

#### 应用场景

多线程环境中，通过队列可以很容易实现数据共享，比如经典的生产者和消费者模型：假设有若干生产者线程，另外又有若干消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决它们之间的数据共享问题。

但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况怎么办？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。（在多线程领域，阻塞是指在某些情况下会挂起线程（阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）


BlockingQueue 保证当队列中没有数据的时候，消费者端的所有线程都会被自动阻塞，直到有数据放入队列；当队列中填满数据的时候，生产者端的所有线程都会被自动阻塞，直到队列中有空的位置，线程被自动唤醒。

利用 BlockingQueue 使得程序员再也不用关心什么时候需要要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都一手包办了。

在多线程进行合作时，阻塞队列是很有用的工具。生产者线程可以定期的把中间结果存到阻塞队列中，而消费者线程把中间结果取出使用。阻塞队列会自动平衡负载，如果生产者线程集运行得比消费者线程集慢，则消费者线程集在等待结果时就会阻塞。如果生产者线程集运行得快，那么它将等待消费者线程集赶上来。


#### 阻塞队列的操作

阻塞队列的操作可以根据响应方式的不同分为四类：

* 抛出一个异常。

	* add（增加一个元素，若队列已满，则抛出一个 IllegalStateException）
	* remove（移除并返回队列头部的元素，若队列为空，则抛出一个 NoSuchElementException）
	* element（返回队列头部元素，若队列为空，则抛出一个 NoSuchElementException）

* 返回一个特殊值。

	* offer（增加一个元素并返回true，若队列已满则返回false）
	* poll（移除并返回队列头部的元素，若队列为空则返回null）
	* peak（返回队列头部元素，若队列为空则返回null）

* 阻塞。

	* put（添加一个元素，若队列已满则阻塞）
	* take（移除并返回队列头部的元素，若队列为空则阻塞）

* 超时。
	
	* offer(e, time, unit)
	* poll(time, unit)
	
	这两个方法都是在指定时限内阻塞，超时则返回false和null。

#### 阻塞队列的四种实现

`java.util.concurrent` 包提供了阻塞队列的四种实现：

* ArrayBlockingQueue 

	基于数组的阻塞队列，它在生产者放入数据和消费者获取数据都是共用同一个锁对象，这意味着这两者无法真正并行运行。这点不同于 LinkedBlockingQueue。

* LinkedBlockingQueue 

	基于链表的阻塞队列，它之所以能够高效的处理并发数据，是因为其对生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行的操作队列中的数据，以此来提高整个队列的并发性能。

	需要注意，构造一个 LinkedBlockingQueue 对象而没有指定其容量大小的话，默认会创建一个无限大容量的对象，这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列填满阻塞产生，JVM 内存就已经被耗尽了。

* DelayQueue

	其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，只有获取数据的操作（消费者）才会被阻塞。

* PriorityBlockingQueue 

	基于优先级的阻塞队列（优先级的判断通过构造函数传入的 Comparator 对象来决定），需要注意的是，PriorityBlockingQueue 不会阻塞生产者队列，而只会在没有可消费的数据时阻塞消费者。因此使用的时候，要确保生产者产生数据的速度不能快于消费者消费数据的速度，否则时间一长就会耗尽 JVM 内存。


BlockingQueue 不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，还自动管理了多线程间的自动等待与唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能。像在 BlockingQueueTest中的示例，程序不需要任何显示的线程同步，而是将阻塞队列数据结构作为一种同步机制。

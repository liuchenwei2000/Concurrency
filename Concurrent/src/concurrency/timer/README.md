## 定时器（Timer） ##

JDK 提供两种定时器，分别是 `java.util.Timer`，称为 Utility 定时器；`java.swing.Timer`，称为 Swing 定时器。

这两种定时器所提供的功能在大体上是类似的。Utility 定时器是一个为一般用途设计的定时器，而 Swing 定时器是专为 Swing 库包准备的。Swing 定时器在一个线程里面为任意多的操作定时，这个定时器往往用在变换文字框的光标、定时显示和隐藏 tooltips 等用户界面上。


### Swing 的线程安全性

如同 AWT 一样，Swing 不是线程安全的，它们均使用单一的线程处理所有来自操作系统的事件。当接到来自 OS 的事件时，会将事件按照队列方式排序，然后依次判断事件的类型，再通知有关的 listener 对象。像 mouseMoved() 这样的事件处理器与依次处理 OS 层次的事件队列的操作是在同一个线程里面的。当事件处理操作运行时，GUI 等于被锁住了。这时，如果用户按某个按键的话，OS 会照常传入事件消息，只是因为事件处理线程被占线，因此事件处理机制不会立即处理这时候传入的消息。因此为了使系统的 GUI 总是保持对用户事件的响应，事件处理操作就应当简短和快速，所有耗费时间的操作都应当利用新的线程处理。

Swing 的类没有一个是线程安全的。如果 Swing 类都设计成线程安全的，引发的复杂性和运行开销之大很难被接受。因此，Swing 的类根本就不是设计用来同时处理多线程的。

缺乏线程安全性意味着一旦系统通过调用诸如 setVisible() 或其他的方法，将一个视窗变成可见的时，事件处理线程便开始运行，这时就无法安全的从 Swing 自己的事件处理器线程之外的任何线程里调用这个视窗的方法。这通常不是一个问题，因为 Swing 构件的方法通常被 Swing 的事件处理器自己调用，注意所有的 listener 方法都是在这个线程上运行的。

一般来说，如果所需要定时的功能与 Swing 无关的话，应当使用 Utility 定时器。而如果设计的系统和所定时的功能是与 Swing 密切相关的话，就应当考虑使用 Swing 定时器。


### 两种定时器在性能上的区别

* Swing 定时器类使用一个线程处理所有的定时器对象，因而不宜用来同时处理大量的定时器对象；而 Utility 定时器则不然，它为每一个定时器对象提供一个独立的线程，因此如果所设计的系统要求大量的定时器对象的话，则使用 Utility 定时器才可满足要求。

* Swing 定时器类的所有定时器对象所用的线程与事件处理器使用的是同一个线程，因此适合于在 Swing 构建中使用。Utility 定时器一般不适用于处理 Swing 构建的定时工作。


### 两种定时器在使用上的区别

Swing 定时器类需要创建一个 Action 对象，以封装被定时的行为；而 Utility 定时器则需要为每一个被定时的任务创建一个 TimerTask 对象，以封装被定时的行为。比较之下，前者很接近观察这模式。


Swing 定时器类使用一个(私有的)线程处理所有的定时器实例。它为需要定时的操作设定调用时间，然后使自己的线程休眠(sleep)。这种设计方式使 Swing 定时器类不能处理大量的定时器。 Swing 定时器对象会在设定好的时间触发一个事件。要实现 Swing 定时器，必须向计时器提供一个 Action 对象，并实现 Action 对象的 actionPerformed 方法，以便执行所指定的操作。


Swing 定时器类使用单一的线程处理所有的定时器对象，这是单例模式的应用。Swing 使用了一个 TimerQueue 对象封装了等待线程，而且这个类是一个单例类。它提供了一个静态工厂方法 sharedInstance()，并通过这个方法提供唯一的一个实例。

当调用 Timer 对象的 start() 方法时，定时就开始了。定时一旦开始，Timer 对象就把自己加入到 TimerQueue 里面。在这以后，TimerQueue 对象会将所有的定时器对象按照触发时间排序，然后将自己转入睡眠状态，等待最近的一个触发时间的到来。当一个触发时间到来时，TimerQueue 会使所触发的定时器对象通知所有的观察者对象。

## 更多 ##

### 5，一些替代独占锁的方法

第三种降低竞争锁的影响的技术是放弃使用独占锁，从而借助于使用一种友好并发的方式来管理共享状态。例如，使用并发容器、读写锁、不可变对象以及原子变量。

ReadWriteLock 实现了一种在多个读取操作以及单个写入操作情况下的加锁规则：如果多个读取操作都不会修改共享资源，那么这些读取操作可以同时访问该共享资源，但在执行写入操作时必须以独占形式来获取锁。对于读取操作占多数的数据结构，ReadWriteLock 能提供比独占锁更高的并发性；而对于只读的数据结构，其中包含的不变性可以完全不需要加锁操作。

原子变量提供了一种方式来降低更新“热点域”时的开销，例如静态计数器、序列发生器等。原子变量类提供了在整数或者对象引用上的细粒度原子操作，并使用了现代处理器中提供的底层并发原语。如果在类中只包含少量的热点域，并且这些域不会与其他变量参与到不变性条件中，那么用原子变量来替代它们能提高可伸缩性。

### 7，向对象池说不

在对象池中，对象能被循环利用，而不是由垃圾收集器回收并在需要是重新分配。在单线程程序中，尽管对象池技术能降低垃圾收集器操作的开销，但对于高开销对象以外的其他对象来说，仍然存在性能缺失，尤其是轻量级和中量级的对象。

在并发应用程序中，对象池的表现更加糟糕。当线程分配新的对象时，基本上不需要再线程之间进行协调，因为对象分配器通常会使用线程本地的内存块，所以不需要在堆数据结构上进行同步。然而，如果这些线程从对象池中请求一个对象，那么就需要通过某种同步来协调对对象池数据结构的访问，从而可能使某个线程被阻塞。如果某个线程由于锁竞争而被阻塞，那么这种阻塞的开销将是内存分配操作开销的数百倍，因此即使对象池带来的竞争很小，也可能形成一个可伸缩性瓶颈。虽然这看似是一种性能优化技术，但实际上却会导致伸缩性问题。对象池有其特定的用途，但对于性能优化来说，用途是有限的。
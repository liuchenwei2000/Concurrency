## 状态依赖性的管理 ##

在单线程程序中调用一个方法时，如果某个基于状态的前提条件未得到满足（例如“连接池必须非空”），那么这个条件就永远无法成真。因此，在编写顺序程序中的类时，要使得这些类在它们的前提条件未被满足时就失败。

但在并发程序中，基于状态的条件可能会由于其他线程的操作而改变：一个资源池可能在几条指令之前还是空的，但现在却变为非空的，因为另一个线程可能会返回一个元素到资源池。对于并发对象上依赖状态的方法，虽然有时候在前提条件不满足的情况下不会失败，但通常会等待前提条件变为真。

依赖状态的操作可以一直阻塞直到可以继续执行，这比让它们直接失败要更为方便且更不易出错。

可阻塞的状态依赖操作的形式伪代码如下：

	acquire lock on object state
	while (precondition does not hold) {
		release lock
		wait until precondition might hold
		optionally fail if interrupted or timeout expires
		reacquire lock
	}
	perform action
	release lock

这种加锁模式有些不同寻常，因为锁是在操作的执行过程中被释放和重新获取的。构成前提条件的状态变量必须由对象的锁来保护，从而使它们在测试前提条件的同时保持不变。如果前提条件尚未满足，就必须释放锁。以便其他线程可以修改对象的状态，否则，前提条件就永远无法变为真。在再次测试前提条件之前，必须重新获得锁。
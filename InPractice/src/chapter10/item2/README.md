## 死锁的避免与诊断 ##

### 支持定时的锁

显式地使用 Lock 类中的定时 tryLock 功能来代替内置锁机制，可以检测死锁和从死锁中恢复过来。当使用内置锁时，只要没有获得锁，就会永远等待下去，而显式锁则可以指定一个超时时限，在等待超过该时间后 tryLock 会返回一个失败信息。如果超时时限比获取锁的时间要长很多，那么就可以在发生某个意外情况后重新获得控制权。

当定时锁失败时，并不需要知道失败的原因，至少能记录所发生的失败，以及关于这次操作的其他有用信息，并通过一种更平缓的方式来重新启动计算，而不是关闭整个进程。

使用定时锁来获取多个锁能有效地应对死锁问题，如果在获取锁时超时，那么可以放弃这个锁，然后后退并在一段时间后再次尝试，从而消除了死锁发生的条件，使程序恢复过来。这项技术只有在同时获取两个锁时才有效，如果在嵌套的方法调用中请求多个锁，那么即使知道已经持有了外层的锁，也无法释放它。

### 通过线程转储信息来分析死锁

JVM 可以通过线程转储（Thread dump）来帮助识别死锁的发生，线程转储包括各个运行中的线程的栈追踪信息，类似于发生异常时的栈追踪信息，还包括加锁信息，例如每个线程持有了哪些锁，在哪些栈帧中获得这些锁，以及被阻塞的线程正在等待获取哪一个锁。
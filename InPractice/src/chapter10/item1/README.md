## 死锁 ##

每个线程都拥有其他线程需要的资源，同时又等待其他线程已经拥有的资源，并且每个线程在获得所有需要的资源之前都不会放弃已经拥有的资源。这就产生了死锁。

当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么它们将永远被阻塞。对于多个线程，由于存在环路的锁依赖关系而永远地等待下去。

当一组 Java 线程发生死锁时，往往意味着游戏结束——这些线程永远不能再使用了。根据线程完成工作的不同，可能造成应用程序完全停止，或者某个特定的子系统停止，或者性能降低。
恢复应用程序的唯一方式就是中止并重启它。
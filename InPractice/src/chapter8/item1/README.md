## 在任务与执行策略之间的隐性耦合 ##

Executor 框架可以将任务的提交与任务的执行策略解耦开来，但并非所有的任务都适用于所有的执行策略。
有些类型的任务需要明确地指定执行策略，如：依赖性任务、使用线程封闭机制的任务、对响应时间敏感的任务、使用 ThreadLocal 的任务。
只有当任务都是同类型的并且相互独立时，线程池的性能才能达到最佳。

### 线程饥饿死锁

在线程池中，如果任务依赖于其他任务，那么可能产生死锁。如果所有正在执行任务的线程都由于等待其他处于工作队列中的任务而阻塞，那就会发生线程饥饿死锁。
只要线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件（如某个任务等待另一个任务的返回值或执行结果），那么除非线程池足够大，否则将发生线程饥饿死锁。

### 运行时间较长的任务

如果线程池中的而线程的数量远小于在稳定状态下执行时间较长任务的数量，那么到最后可能所有的线程都在运行这些执行时间较长的任务，从而影响整体的响应性。
有一项技术可以缓解执行时间较长任务造成的影响，即限定任务等待资源的时间，而不要无限制地等待。
在平台类库的大多数可阻塞方法中，都同时定义了限时版本和无限时版本，例如 BlockingQueue.put、CountDownLatch.await 等。
如果等待超时，那么可以把任务标识为失败，然后中止任务或者将任务重新放回队列以便随后执行。
这样无论任务的最终结果是否成功，都能确保任务总能继续执行下去，并将线程释放出来以执行一些能更快完成的任务。
如果在线程池中总是充满了被阻塞的任务，那么也可能表明线程池的规模过小。

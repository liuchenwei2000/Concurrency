## 原子变量与非阻塞同步机制 ##

在并发算法领域的大多数研究都侧重于非阻塞算法，这种算法用底层的原子机器指令（例如比较并交换指令）代替锁来确保数据在并发访问中的一致性。非阻塞算法被广泛地用于在操作系统和 JVM 中实现线程/进程调度机制、垃圾回收机制以及锁和其他并发数据结构。

与基于锁的方案相比，非阻塞算法在设计和实现上都要复杂得多，但它们在可伸缩性和活跃性上却拥有巨大的优势。由于非阻塞算法可以使多个线程在竞争相同的数据时不会发生阻塞，因此它能在粒度更细的层次上进行协调，并且极大地减少调度开销。而且，在非阻塞算法中不存在死锁和其他活跃性问题。从 Java5 开始，可以使用原子变量类（AtomicInteger 和 AtomicReference）来构建高效的非阻塞算法。

即使原子变量没有用于非阻塞算法的开发，它们也可以用做一种“更好的 volatile 类型变量”。原子变量提供了与 volatile 类型变量相同的内存语义，此外还支持原子的更新操作，从而使它们更适用于实现计数器、序列生成器和统计数据收集等，同时还能比基于锁的方法提供更高的可伸缩性。
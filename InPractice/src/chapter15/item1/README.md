## 锁的劣势 ##

通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都能采用独占方式来访问这些变量，并且对变量的任何修改对随后获得锁的其他线程都是可见的。

现代的许多 JVM 都对非竞争锁获取和锁释放等操作进行了极大的优化，但如果多个线程同时请求锁，那么 JVM 就需要借助操作系统的功能。如果出现了这种情况，那么一些线程将被挂起并且在稍后恢复运行。当线程恢复运行时，必须等待其他线程执行完它们的时间片以后，才能被调度执行。在挂起和恢复线程等过程中存在着很大的开销，并且通常存在着较长时间的中断。如果在基于锁的类中包含有细粒度的操作，那么当在锁上存在着激烈的竞争时，调度开销与工作开销的比值会非常高。

锁还存在着其他一些缺点。当一个线程正在等待锁时，它不能做其他任何事情。如果一个线程在持有锁的情况下被延迟执行（如发生了缺页错误、调度延迟等），那么所有需要这个锁的线程都无法执行下去。另外还有死锁、活锁或者其他的活跃性故障。

与锁相比，volatile 变量是一种更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换或线程调度等操作。然而，volatile 变量同样存在一些局限：虽然它们提供了相似的可见性保证，但不能用于构建原子的复合操作。因此，当一个变量依赖其他的变量时，或者当变量的新值依赖于旧值时，就不能使用 volatile 变量。这些都限制了 volatile 变量的使用，因此它们不能用来实现一些常见的工具，例如计数器或互斥体（mutex）。
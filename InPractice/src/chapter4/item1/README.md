## 设计线程安全的类 ##

### 收集同步需求

要确保类的线程安全性，就需要确保它的**不变性条件**不会在并发访问的情况下被破坏，这就需要对其状态进行推断。final 类型的域使用的越多，就越能简化对象可能状态的分析过程。

在许多类中都定义了一些**不变性条件**，用于判断状态是有效的还是无效的。同样还会包含一些**后验条件**来判断状态转换是否是有效的。当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。

由于**不变性条件**以及**后验条件**在状态及状态转换上施加了约束，因此就需要额外的同步与封装。如果某些状态是无效的，那么必须对底层的状态变量进行封装，否则客户代码可能会使对象处于无效状态。如果在某个操作中存在无效的状态转换，那么该操作必须是原子的。

包含多个变量的不变性条件将带来原子性需求：这些相关的变量必须在单个原子操作中进行读取或更新。不能首先更新一个变量，然后释放锁并再次获得锁，然后再更新其他的变量。因为释放锁后，可能会使对象处于无效状态。如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的值。

### 依赖状态的操作

在某些对象的方法中还包含一些基于状态的先验条件。例如移除某个队列的元素之前要检查队列是否处于非空状态。如果在某个操作中包含有基于状态的先验条件，那么这个操作就被称为依赖状态的操作。

在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中，先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一直等到先验条件为真然后再执行该操作。

在 Java 中，等待某个条件为真的各种内置机制都与内置加锁机制紧密关联，要想实现某个等待先验条件为真时才执行的操作，一种简单的方法是通过现有库中的类（如阻塞队列或Semaphore）来实现依赖状态的行为。

### 状态的所有权

对象封装它拥有的状态，也对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。所有权意味着控制权。然而，如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多是共享控制权。对于从构造函数或者从方法中传递进来的对象，类通常并不拥有这些对象，除非这些方法是被专门设计为转移传递进来的对象的所有权（例如同步容器封装器的工厂方法）。
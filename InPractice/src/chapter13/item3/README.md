## 公平性 ##

在 ReentrantLock 的构造函数中提供了两种公平性选择：创建一个非公平的锁（默认）或者公平的锁。在公平的锁上，线程将按照它们发出请求的顺序来获得锁，但在非公平的锁上，则允许插队：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。（在 Semaphore 中同样可以选择采用公平的或非公平的获取顺序。）非公平的 ReentrantLock 并不提倡插队行为，但无法防止某个线程在合适的时候进行插队。在公平的锁中，如果有另一个线程持有这个锁或者由其他线程在队列中等待这个锁，那么新发出请求的线程将被放入队列中。在非公平的锁中，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中。（即使对于公平锁而言，可轮询的 同样 同样tryLock 仍然会插队。）

当执行加锁操作时，公平性将由于在挂起线程和恢复线程时存在的开销而极大地降低性能。在激烈竞争的情况下，非公平锁的性能高于公平锁的一个原因是：在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设线程 A 持有一个锁，并且线程 B 请求这个锁。由于这个锁已被线程 A 持有，因此 B 将被挂起。当 A 释放锁时，B 将被唤醒，因此会再次尝试获取锁。与此同时，如果线程 C 也请求这个锁，那么 C 很可能会在 B 被完全唤醒之前获得、使用以及释放这个锁。B 获得锁的时刻并没有推迟，C 更早地获得了锁，并且吞吐量也获得了提高。（“来得早不如来得巧”）

当持有锁的时间相对较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。

Java 语言规范并没有要求 JVM 以公平的方式来实现内置锁，而在各种 JVM 中也没有这样做。
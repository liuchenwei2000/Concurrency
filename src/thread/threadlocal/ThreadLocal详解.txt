
首先，ThreadLocal不是用来解决共享对象的多线程访问问题的，一般情况下，通过ThreadLocal.set()到线程中的对象是该线程自己使用的对象，
其他线程是不需要访问的，也访问不到。各个线程中访问的是不同的对象。 

另外，说ThreadLocal使得各线程能够保持各自独立的一个对象实例，并不是通过ThreadLocal.set()来实现的，
而是通过每个线程中的new对象的操作来创建的对象，每个线程创建一个实例，不是什么对象的拷贝或副本。
如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题。 


实现细节

可以将ThreadLocal<T>视为包含了Map<Thread,T>对象，其中记录了特定于某线程的值，但ThreadLocal的实现并非如此。
这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。


与synchronized的区别

synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。
而ThreadLocal为每一个线程都提供了变量的不同实例，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。
而synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。 


使用场景

假设需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象（如果全局变量的语义允许），可以维持线程安全性。
此外，这种方式是――――把有状态类描绘成线程安全的，或者封装非线程安全类以使它们能够在多线程环境中安全地使用的――――最容易的方式。
使用ThreadLocal使我们可以绕过为实现线程安全而对何时需要同步进行判断的复杂过程，而且因为它不需要任何同步，所以也改善了可伸缩性。
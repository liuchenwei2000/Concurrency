                                                                                          定时器(Timer)专题


JDK提供两种定时器，分别是java.util.Timer，称为Utility定时器；java.swing.Timer，称为Swing定时器。

这两种定时器所提供的功能在大体上是类似的。
Utility定时器是一个为一般用途设计的定时器，而Swing定时器是专为Swing库包准备的。
Swing定时器在一个线程里面为任意多的操作定时，这个定时器往往用在变换文字框的光标、定时显示和隐藏tooltips等用户界面上。


Swing的线程安全性

如同AWT一样，Swing不是线程安全的，它们均使用单一的线程处理所有来自操作系统的事件。
当接到来自OS的事件时，会将事件按照队列方式排序，然后依次判断事件的类型，再通知有关的listener对象。
像mouseMoved()这样的事件处理器与依次处理OS层次的事件队列的操作是在同一个线程里面的。
当事件处理操作运行时，GUI等于被锁住了。
这时，如果用户按某个按键的话，OS会照常传入事件消息，只是因为事件处理线程被占线，因此事件处理机制不会立即处理这时候传入的消息。
因此为了使系统的GUI总是保持对用户事件的响应，事件处理操作就应当简短和快速，所有耗费时间的操作都应当利用新的线程处理。

Swing的类没有一个是线程安全的。如果Swing类都设计成线程安全的，引发的复杂性和运行开销之大很难被接受。
因此，Swing的类根本就不是设计用来同时处理多线程的。
缺乏线程安全性意味着一旦系统通过调用诸如setVisible()或其他的方法，将一个视窗变成可见的时，事件处理线程便开始运行，
这时就无法安全的从Swing自己的事件处理器线程之外的任何线程里调用这个视窗的方法。
这通常不是一个问题，因为Swing构件的方法通常被Swing的事件处理器自己调用，注意所有的listener方法都是在这个线程上运行的。

一般来说，如果所需要定时的功能与Swing无关的话，应当使用Utility定时器。
而如果设计的系统和所定时的功能是与Swing密切相关的话，就应当考虑使用Swing定时器。


两种定时器在性能上的区别
1，Swing定时器类使用一个线程处理所有的定时器对象，因而不宜用来同时处理大量的定时器对象；
而Utility定时器则不然，它为每一个定时器对象提供一个独立的线程，因此如果所设计的系统要求大量的定时器对象的话，则使用Utility定时器才可满足要求。
2，Swing定时器类的所有定时器对象所用的线程与事件处理器使用的是同一个线程，因此适合于在Swing构建中使用。
Utility定时器一般不适用于处理Swing构建的定时工作。


两种定时器在使用上的区别
Swing定时器类需要创建一个Action对象，以封装被定时的行为；
而Utility定时器则需要为每一个被定时的任务创建一个TimerTask对象，以封装被定时的行为。
比较之下，前者很接近观察这模式。


Swing定时器类使用一个(私有的)线程处理所有的定时器实例。它为需要定时的操作设定调用时间，然后使自己的线程休眠(sleep)。
这种设计方式使Swing定时器类不能处理大量的定时器。Swing定时器对象会在设定好的时间触发一个事件。
要实现Swing定时器，必须向计时器提供一个Action对象，并实现Action对象的actionPerformed方法，以便执行所指定的操作。


Swing定时器类使用单一的线程处理所有的定时器对象，这是单例模式的应用。
Swing使用了一个TimerQueue对象封装了等待线程，而且这个类是一个单例类。
它提供了一个静态工厂方法sharedInstance()，并通过这个方法提供唯一的一个实例。
当调用Timer对象的start()方法时，定时就开始了。定时一旦开始，Timer对象就把自己加入到TimerQueue里面。
在这以后，TimerQueue对象会将所有的定时器对象按照触发时间排序，然后将自己转入睡眠状态，等待最近的一个触发时间的到来。
当一个触发时间到来时，TimerQueue会使所触发的定时器对象通知所有的观察者对象。
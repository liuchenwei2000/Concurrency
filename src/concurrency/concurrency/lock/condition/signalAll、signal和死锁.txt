signalAll、signal和死锁


最终必须要有某个线程调用signalAll方法，这一点很重要。当一个线程调用了await时，它无法自己解除阻塞状态，它把自己的命运交给了其他线程。
如果没有任何其他的线程来解除等待线程的阻塞状态，它就永远也不会运行了，这就会导致死锁。

适时调用signalAll的原则：当对象的状态向着有利于等待线程的方向变化时调用。例如，当一个账户余额发生变化时，等待线程应该有机会去检查余额。

需要注意的是，对singanlAll的调用不会立即激活等待线程，它只是解除等待线程的阻塞状态，这样这些线程就可以在当前线程推出同步方法（释放对象锁）后，通过竞争获得对对象的访问。

singal方法是随机解除等待集中某个线程的阻塞状态，这比解除所有线程的阻塞状态更好用，但也存在危险。
如果被随机选中的线程发现自己还是无法运行，它会被再次阻塞，如果没有任何其他线程再次调用signal方法，那么系统就死锁了。
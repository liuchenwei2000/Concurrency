线程同步


同步格言：如果向一个变量写值，而这个变量接下来可能会被另一个线程所读取，或者从一个变量读值，而它的值可能是前面由另一个线程写入的，此时必须使用同步。

有两个或多个线程需要同时对相同的对象进行存取，而且每一个都调用了一个会改变对象状态的方法，那这些线程会相互倾轧，根据各个线程访问数据的不同顺序，可能会产生腐蚀的对象。这种情况通常称作竞争条件 (race condition)。

锁定是控制多个线程对共享资源进行访问的工具。通常，锁定提供了对共享资源的独占访问。一次只能有一个线程获得锁定，对共享资源的所有访问都需要首先获得锁定。

有两种机制来保护代码块不受并行访问的干扰，旧版本的Java使用synchronized关键字，而JDK5.0引入了Lock类。

从JDK1.0开始，Java中每个对象都有一个隐式的锁，如果一个方法由synchronized关键字修饰，那么对象的锁将保护整个方法，要调用这个方法，线程必须先获得对象的锁。

隐式对象锁只有一个关联条件(condition)，由锁来管理试图进入synchronized方法的线程，而由条件来管理那些需要等待的线程。

隐式的锁和条件存在一些缺点，如下：
1，不能中断一个正在试图获得锁的线程。
2，试图获得锁时不能设定超时。
3，每个锁只有一个条件有时显得不够用。
4，虚拟机的加锁原语不能很好地映射到硬件可用的最有效的加锁机制上。

对于Lock和Condition的关键点，如下：
1，锁可以用来保护代码片段，任何时刻只允许一个线程执行被保护的代码。
2，锁可以管理试图进入被保护代码段的线程。
3，锁可以拥有一个或者多个相关的条件对象。
4，每个条件对象管理那些已进入被保护代码段但还不能运行的线程。
阻塞队列(BlockingQueue)


BlockingQueue很好地解决了多线程中，如何高效安全传输数据的问题，通过这些高效并且线程安全的队列类，可以更快的搭建高质量的多线程程序。

应用场景：

多线程环境中，通过队列可以很容易实现数据共享，比如经典的生产者和消费者模型中，通过队列可以很便利的实现两者之间的数据共享。

假设有若干生产者线程，另外又有若干消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便的解决它们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况怎么办？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。（在多线程领域，阻塞是指在某些情况下会挂起线程（阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）

在concurrent包发布以前，在多线程环境下，每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给程序带来不小的复杂度。

BlockingQueue保证当队列中没有数据的时候，消费者端的所有线程都会被自动阻塞，直到有数据放入队列；当队列中填满数据的时候，生产者端的所有线程都会被自动阻塞，直到队列中有空的位置，线程被自动唤醒。利用BlockingQueue使得程序员再也不用关心什么时候需要要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都一手包办了。

在多线程进行合作时，阻塞队列是很有用的工具。生产者线程可以定期的把中间结果存到阻塞队列中，而消费者线程把中间结果取出使用。阻塞队列会自动平衡负载，如果生产者线程集运行得比消费者线程集慢，则消费者线程集在等待结果时就会阻塞。如果生产者线程集运行得快，那么它将等待消费者线程集赶上来。

阻塞队列的操作可以根据相应方式的不同分为四类：

1，抛出一个异常。包括
add（增加一个元素，若队列已满，则抛出一个IllegalStateException）
remove（移除并返回队列头部的元素，若队列为空，则抛出一个NoSuchElementException）
element（返回队列头部元素，若队列为空，则抛出一个NoSuchElementException）

2，返回一个特殊值。包括
offer（增加一个元素并返回true，若队列已满则返回false）
poll（移除并返回队列头部的元素，若队列为空则返回null）
peak（返回队列头部元素，若队列为空则返回null）

3，阻塞。包括
put（添加一个元素，若队列已满则阻塞）
take（移除并返回队列头部的元素，若队列为空则阻塞）

4，超时。包括
offer(e, time, unit)
poll(time, unit)
这两个方法都是在指定时限内阻塞，超时则返回false和null。


java.util.concurrent包提供了阻塞队列的四种实现：

1，ArrayBlockingQueue

基于数组的阻塞队列，它在生产者放入数据和消费者获取数据都是共用同一个锁对象，这意味着这两者无法真正并行运行。这点不同于LinkedBlockingQueue。

2，LinkedBlockingQueue

基于链表的阻塞队列，它之所以能够高效的处理并发数据，是因为其对生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行的操作队列中的数据，以此来提高整个队列的并发性能。

需要注意，构造一个LinkedBlockingQueue对象而没有指定其容量大小的话，默认会创建一个无限大容量的对象，这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列填满阻塞产生，JVM内存就已经被耗尽了。

3，DelayQueue

其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，只有获取数据的操作（消费者）才会被阻塞。

4，PriorityBlockingQueue

基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），需要注意的是，PriorityBlockingQueue不会阻塞生产者队列，而只会在没有可消费的数据时，阻塞消费者。因此使用的时候，要确保生产者产生数据的速度不能快于消费者消费数据的速度，否则时间一长就会耗尽JVM内存。


BlockingQueue不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，还自动管理了多线程间的自动等待与唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能。像在BlockingQueueTest中的示例，程序不需要任何显示的线程同步，而是将阻塞队列数据结构作为一种同步机制。
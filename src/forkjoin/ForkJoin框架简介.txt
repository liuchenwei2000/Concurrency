

Fork/Join框架主要用来解决那些可以使用“分而治之”策略分解为更小任务的问题。
在每个任务中，需要检查其大小，如果大于某个确定的阈值，则使用框架继续将其分解成更小的任务；
如果小于阈值，则直接在任务中解决该问题（可选地返回一个结果）。阈值的确定完全依赖于问题本身，而没有什么公式。


Fork/Join框架依赖于下面两类操作：
1，fork
表示将任务分解成更小的任务，并使用框架运行这些小任务。
2，join
表示一个任务等待它所分解的小任务运行结束。


可以把ForkJoinPool看作一个特殊的Executor，但它跟Executor框架的不同之处在于工作窃取（work-stealing）算法。
对于ForkJoinPool而言，当一个任务T执行join操作等待它所创建的子任务运行结束期间，运行任务T的线程（称为worker thread）会主动寻找其他尚未被执行的任务并运行它。
这样一来，线程们充分利用了运行时间，所以极大的提升了程序性能。

工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。
并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。


为了达到上述目的，用Fork/Join框架执行的任务有如下限制：
1，任务只能使用fork()和join()操作作为同步机制。如果使用了其他的同步机制，那worker threads在同步操作期间可能就不会执行其他任务。
比如在使用Fork/Join框架时，将一个任务设置为sleep一段时间，则执行该任务的线程会sleep一段时间而在此期间不会再执行其他任务。
2，任务不能够执行IO操作，比如从文件中读写数据。
3，任务不能抛出受查异常，必须有特定代码处理它们。


Fork/Join框架的核心主要包括两个类：
1，ForkJoinPool
它实现了ExecutorService接口和工作窃取算法，管理所有worker threads并提供如任务状态、执行状态等信息。
2，ForkJoinTask
可运行在ForkJoinPool中的任务基类，主要提供在任务内执行fork()和join()操作的机制，还能够控制任务状态。
通常需要实现自己的Fork/Join任务，可以直接继承ForkJoinTask的两个子类：
RecursiveAction（没有返回结果的任务）和RecursiveTask（有返回结果的任务）。


使用步骤如下：

1，创建一个ForkJoinPool实例。
2，实现ForkJoinTask，其实例运行在ForkJoinPool中。

## Fork/Join 框架简介 ##

Fork/Join 框架主要用来解决那些可以使用“分而治之”策略分解为更小任务的问题。

在每个任务中，需要检查其大小，如果大于某个确定的阈值，则使用框架继续将其分解成更小的任务；如果小于阈值，则直接在任务中解决该问题（可选地返回一个结果）。阈值的确定完全依赖于问题本身，而没有什么公式。


Fork/Join 框架依赖于下面两类操作：

* fork

	表示将任务分解成更小的任务，并使用框架运行这些小任务。

* join

	表示一个任务等待它所分解的小任务运行结束。


可以把 ForkJoinPool 看作一个特殊的 Executor，但它跟 Executor 框架的不同之处在于工作窃取（work-stealing）算法。

对于 ForkJoinPool 而言，当一个任务 T 执行 join 操作等待它所创建的子任务运行结束期间，运行任务T的线程（称为 worker thread）会主动寻找其他尚未被执行的任务并运行它。这样一来，线程们充分利用了运行时间，所以极大的提升了程序性能。

工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。


为了达到上述目的，用 Fork/Join 框架执行的任务有如下限制：

* 任务只能使用 `fork()` 和 `join()` 操作作为同步机制。如果使用了其他的同步机制，那 worker threads 在同步操作期间可能就不会执行其他任务。比如在使用 Fork/Join 框架时，将一个任务设置为 sleep 一段时间，则执行该任务的线程会 sleep 一段时间而在此期间不会再执行其他任务。

* 任务不能够执行 IO 操作，比如从文件中读写数据。

* 任务不能抛出受查异常，必须有特定代码处理它们。


### 核心类 ###

Fork/Join 框架的核心主要包括两个类：

* `ForkJoinPool`
	
	它实现了 ExecutorService 接口和工作窃取算法，管理所有 worker threads 并提供如任务状态、执行状态等信息。

* `ForkJoinTask`

	可运行在 ForkJoinPool 中的任务基类，主要提供在任务内执行 `fork()` 和 `join()` 操作的机制，还能够控制任务状态。

通常需要实现自己的 Fork/Join 任务，可以直接继承 ForkJoinTask 的两个子类：
`RecursiveAction`（没有返回结果的任务）和 `RecursiveTask`（有返回结果的任务）。


使用步骤如下：

* 创建一个 ForkJoinPool 实例。
* 实现 ForkJoinTask，其实例运行在 ForkJoinPool 中。
